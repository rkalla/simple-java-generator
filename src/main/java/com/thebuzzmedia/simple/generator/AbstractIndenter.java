/**   
 * Copyright 2011 The Buzz Media, LLC
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.thebuzzmedia.simple.generator;

import java.util.HashMap;
import java.util.Map;

/**
 * Default base implementation of an {@link IIndenter}.
 * <p/>
 * In addition to core indenter functionality, this class also automatically
 * implements caching of the generated indent by way of the provided
 * {@link #getIndent(Type, Position, int)} method which only calls the
 * user-specified {@link #getIndentImpl(Type, Position, int)} method when a
 * pre-created <code>char[]</code> indent for the same arguments cannot be found
 * in the internal indent cache.
 * <p/>
 * Given the structured/repeating nature of most file formats generated by this
 * library (JSON, XML, etc.), it is common to only create a few different
 * indentations for an entire document and just re-use them over and over again;
 * so a cache here offers big wins in performance during generation.
 * <p/>
 * This provides extremely fast performance for any custom {@link IIndenter}
 * implementation that extends this class.
 * 
 * @author Riyad Kalla (software@thebuzzmedia.com)
 * @since 1.1
 */
public abstract class AbstractIndenter implements IIndenter {
	/**
	 * Default mode of indentation used by indenters extending this class.
	 * <p/>
	 * Default value is: TAB
	 */
	public static final Mode DEFAULT_MODE = Mode.TAB;

	/**
	 * Default indent multiple used by indenters extending this class.
	 * <p/>
	 * Default value is: 1
	 */
	public static final int DEFAULT_INDENT_MULTIPLE = 1;

	private Mode mode;
	private int indentMultiple;
	private Map<Integer, char[]> indentCache;

	public AbstractIndenter() {
		this(DEFAULT_MODE);
	}

	public AbstractIndenter(Mode mode) throws IllegalArgumentException {
		this(mode, DEFAULT_INDENT_MULTIPLE);
	}

	public AbstractIndenter(Mode mode, int indentMultiple)
			throws IllegalArgumentException {
		setMode(mode);
		setIndentMultiple(indentMultiple);

		indentCache = new HashMap<Integer, char[]>(64);
	}

	public Mode getMode() {
		return mode;
	}

	public void setMode(Mode mode) throws IllegalArgumentException {
		if (mode == null)
			throw new IllegalArgumentException("mode cannot be null");

		this.mode = mode;
	}

	public int getIndentMultiple() {
		return indentMultiple;
	}

	public void setIndentMultiple(int indentMultiple)
			throws IllegalArgumentException {
		if (indentMultiple < 1)
			throw new IllegalArgumentException("indentMultiple ["
					+ indentMultiple + "] must be >= 1");

		this.indentMultiple = indentMultiple;
	}

	/**
	 * Implemented to check an internal <code>char[]</code> cache for an
	 * existing indentation for the same set of arguments and return it,
	 * otherwise delegate to {@link #getIndentImpl(Type, Position, int)} to
	 * create it.
	 * <p/>
	 * This method calculates if an existing cached <code>char[]</code> exists
	 * for these arguments by using the following key as a lookup:
	 * 
	 * <pre>
	 * int key = type.hashCode() + position.hashCode() + level;
	 * </pre>
	 */
	public char[] getIndent(Type type, Position position, int level)
			throws IllegalArgumentException {
		if (type == null)
			throw new IllegalArgumentException("type cannot be null");
		if (position == null)
			throw new IllegalArgumentException("position cannot be null");
		if (level < 0)
			throw new IllegalArgumentException("level must be >= 0");

		// Calculate the cache lookup key
		Integer key = Integer.valueOf(type.hashCode() + position.hashCode()
				+ level);

		// Attempt to pull an indent from the cache
		char[] indent = indentCache.get(key);

		// If the indent wasn't cached, calculate it and cache it.
		if (indent == null) {
			indent = getIndentImpl(type, position, level);
			indentCache.put(key, indent);
		}

		return indent;
	}

	/**
	 * Convenience method used to generate a <code>char[]</code> representing an
	 * indent for the given level, the current indent multiple set on this
	 * indenter and a newline char ('\n') prepended to the result if necessary.
	 * 
	 * @param level
	 *            The indentation level to generate.
	 * @param prependLF
	 *            If a newline char ('\n') should be pre-pended to the
	 *            indentation or not.
	 * 
	 * @return a <code>char[]</code> representing an indent for the given level,
	 *         the current indent multiple set on this indenter and a newline
	 *         char ('\n') prepended to the result if necessary.
	 */
	protected char[] createIndent(int level, boolean prependLF) {
		char c = mode.getIndentCharacter();
		char[] indent = new char[(level * indentMultiple) + (prependLF ? 1 : 0)];

		int i = 0;

		if (prependLF) {
			i = 1;
			indent[0] = '\n';
		}

		for (; i < indent.length; i++)
			indent[i] = c;

		return indent;
	}

	/**
	 * Method used to implement the logic for actually creating the indentation
	 * <code>char[]</code> based on the given arguments.
	 * <p/>
	 * This method is only called when calls to
	 * {@link #getIndent(Type, Position, int)} cannot find a suitable
	 * indentation in the internal indent cache.
	 * <p/>
	 * Results returned from this method are automatically cached and re-used.
	 * Implementors do not need to implement caching logic in overrides of this
	 * method.
	 * 
	 * @param type
	 *            The type of element being indented.
	 * @param position
	 *            The fine-tune position of the element that is being indented.
	 * @param level
	 *            The indentation level.
	 * 
	 * @return a <code>char[]</code> representing a suitable indentation for the
	 *         given arguments.
	 */
	protected abstract char[] getIndentImpl(Type type, Position position,
			int level);
}